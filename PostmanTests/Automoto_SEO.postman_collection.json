{
	"info": {
		"_postman_id": "e1cd4d1f-5916-4ab4-a00a-822e64bb4cae",
		"name": "LV RU",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "47857381",
		"_collection_link": "https://www.postman.com/yaroslav-samodzin-s-team/workspace/yaroslav-samodzin/collection/47857381-e1cd4d1f-5916-4ab4-a00a-822e64bb4cae?action=share&source=collection_link&creator=47857381"
	},
	"item": [
		{
			"name": "Title",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status 200\", () => pm.response.to.have.status(200));\r",
							"pm.test(\"Response time is less than 200ms\", function () {\r",
							"  pm.expect(pm.response.responseTime).to.be.below(200);\r",
							"});\r",
							"// 1) Title\r",
							"const html = pm.response.text();\r",
							"const m = html.match(/<title[^>]*>([\\s\\S]*?)<\\/title>/i);\r",
							"const title = (m && m[1] || \"\").replace(/\\s+/g, \" \").trim();\r",
							"pm.collectionVariables.set(\"lastPageTitle\", title);\r",
							"pm.test(\"Title існує\", () => pm.expect(title).to.not.be.empty);\r",
							"\r",
							"// 2) utils\r",
							"const canon = s => String(s||\"\").toLowerCase().replace(/-/g,\" \").replace(/\\s+/g,\" \").trim();\r",
							"const titleC = canon(title);\r",
							"\r",
							"// трансліт латинка->ру\r",
							"function latinToRu(s){\r",
							"  s = String(s||\"\").toLowerCase();\r",
							"  const pairs = [\r",
							"    [/shch/g,\"щ\"], [/sch/g,\"щ\"], [/zh/g,\"ж\"], [/ch/g,\"ч\"], [/sh/g,\"ш\"],\r",
							"    [/yo/g,\"ё\"], [/yu/g,\"ю\"], [/ya/g,\"я\"], [/ye/g,\"е\"], [/kh/g,\"х\"], [/ts/g,\"ц\"]\r",
							"  ];\r",
							"  pairs.forEach(([re,rep]) => s = s.replace(re,rep));\r",
							"  const map = {a:\"а\",b:\"б\",c:\"к\",d:\"д\",e:\"е\",f:\"ф\",g:\"г\",h:\"х\",i:\"и\",j:\"й\",k:\"к\",l:\"л\",m:\"м\",n:\"н\",o:\"о\",p:\"п\",q:\"к\",r:\"р\",s:\"с\",t:\"т\",u:\"у\",v:\"в\",w:\"в\",x:\"кс\",y:\"ы\",z:\"з\",\"’\":\"\", \"'\":\"\"};\r",
							"  s = s.split(\"\").map(ch => map[ch] ?? ch).join(\"\");\r",
							"  // локальна правка під Tallin\r",
							"  s = s.replace(/таллинн/g,\"таллин\");\r",
							"  return s;\r",
							"}\r",
							"// простий ру->лат (достатньо для пошуку)\r",
							"function ruToLatin(s){\r",
							"  s = String(s||\"\").toLowerCase();\r",
							"  const map = {а:\"a\",б:\"b\",в:\"v\",г:\"g\",д:\"d\",е:\"e\",ё:\"yo\",ж:\"zh\",з:\"z\",и:\"i\",й:\"y\",\r",
							"               к:\"k\",л:\"l\",м:\"m\",н:\"n\",о:\"o\",п:\"p\",р:\"r\",с:\"s\",т:\"t\",у:\"u\",ф:\"f\",\r",
							"               х:\"kh\",ц:\"ts\",ч:\"ch\",ш:\"sh\",щ:\"shch\",ъ:\"\",ы:\"y\",ь:\"\",э:\"e\",ю:\"yu\",я:\"ya\"};\r",
							"  return s.split(\"\").map(ch => map[ch] ?? ch).join(\"\");\r",
							"}\r",
							"\r",
							"// 3) Парсимо URL\r",
							"const path = pm.request.url.path.slice();\r",
							"const buIdx = path.findIndex(p => /^bu-avto$/i.test(p) || /^auto$/i.test(p));\r",
							"const i = buIdx >= 0 ? buIdx + 1 : 0;\r",
							"const norm = s => decodeURIComponent(String(s||\"\"))\r",
							"  .replace(/\\.html$/i,\"\").replace(/-/g,\" \").replace(/\\s+/g,\" \").trim();\r",
							"\r",
							"const tokens = {\r",
							"  country: norm(path[i] || \"\"),      // estoniya\r",
							"  city:    norm(path[i+1] || \"\"),    // tallin\r",
							"  brand:   norm(path[i+2] || \"\"),    // lada\r",
							"  model:   norm(path[i+3] || \"\"),    // niva\r",
							"  year:    (path[i+4] || \"\").replace(/[^\\d]/g,\"\") // 2003\r",
							"};\r",
							"\r",
							"// 4) Допустимі варіанти написання для кожного токена\r",
							"function variants(s){\r",
							"  if (!s) return [];\r",
							"  const v = new Set();\r",
							"  v.add(canon(s));                   // як у URL\r",
							"  v.add(canon(latinToRu(s)));        // лат -> ру\r",
							"  v.add(canon(ruToLatin(s)));        // ру -> лат (на випадок кирилиці в URL)\r",
							"  return Array.from(v).filter(Boolean);\r",
							"}\r",
							"\r",
							"function expectToContain(label, list){\r",
							"  if (!list.length) return;\r",
							"  pm.test(`Title містить ${label}`, () => {\r",
							"    const ok = list.some(x => titleC.includes(x));\r",
							"    if (!ok) {\r",
							"      console.log(`MISS ${label}`, {title, candidates:list});\r",
							"    }\r",
							"    pm.expect(ok, `не знайдено жодного з: ${list.join(\" | \")}`).to.be.true;\r",
							"  });\r",
							"}\r",
							"\r",
							"// 5) Перевірки\r",
							"// country робимо м'яким (часто її немає у title) — лише лог\r",
							"const countryCands = variants(tokens.country);\r",
							"if (!countryCands.some(x => titleC.includes(x))) {\r",
							"  console.log(\"Country not found in title (це ок)\", {country: tokens.country, candidates: countryCands, title});\r",
							"}\r",
							"\r",
							"// обов'язкові: brand, model, city, year\r",
							"expectToContain(\"brand\", variants(tokens.brand));   // lada / лада\r",
							"expectToContain(\"model\", variants(tokens.model));   // niva / нива\r",
							"expectToContain(\"city\",  variants(tokens.city));    // tallin / таллин\r",
							"pm.test(\"Title має рік\", () => pm.expect(new RegExp(`\\\\b${tokens.year}\\\\b`).test(titleC)).to.be.true);\r",
							"\r",
							"// 6) Перевірка ціни\r",
							"const priceRegex = /по цене\\s*(\\d+)[€]/i;\r",
							"const priceMatch = html.match(priceRegex);\r",
							"const price = priceMatch ? parseInt(priceMatch[1], 10) : null;\r",
							"\r",
							"pm.test(\"Ціна існує і є числом\", () => {\r",
							"    pm.expect(price).to.not.be.null;\r",
							"    pm.expect(price).to.be.a('number');\r",
							"});\r",
							"\r",
							"// Додаткова перевірка на відомий діапазон цін (замініть нижчу і верхню межу на відповідні значення)\r",
							"const minPrice = 1000; //можна добавити змінну яка буде тягнути з фільтрів\r",
							"const maxPrice = 2000; //можна добавити змінну яка буде тягнути з фільтрів\r",
							"pm.test(\"Ціна в допустимому діапазоні\", () => {\r",
							"    pm.expect(price).to.be.within(minPrice, maxPrice);\r",
							"});\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://automoto.com.lv/ru/bu-avto/estoniya/tallin/lada/niva/2003/68589464.html",
					"protocol": "https",
					"host": [
						"automoto",
						"com",
						"lv"
					],
					"path": [
						"ru",
						"bu-avto",
						"estoniya",
						"tallin",
						"lada",
						"niva",
						"2003",
						"68589464.html"
					]
				}
			},
			"response": []
		},
		{
			"name": "New Request",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status 200\", () => pm.response.to.have.status(200));\r",
							"pm.test(\"Response time is less than 200ms\", function () {\r",
							"  pm.expect(pm.response.responseTime).to.be.below(200);\r",
							"});\r",
							"// 1) Title\r",
							"const html = pm.response.text();\r",
							"const m = html.match(/<title[^>]*>([\\s\\S]*?)<\\/title>/i);\r",
							"const title = (m && m[1] || \"\").replace(/\\s+/g, \" \").trim();\r",
							"pm.collectionVariables.set(\"lastPageTitle\", title);\r",
							"pm.test(\"Title існує\", () => pm.expect(title).to.not.be.empty);\r",
							"\r",
							"// 2) utils\r",
							"const canon = s => String(s||\"\").toLowerCase().replace(/-/g,\" \").replace(/\\s+/g,\" \").trim();\r",
							"const titleC = canon(title);\r",
							"\r",
							"// трансліт латинка->ру\r",
							"function latinToRu(s){\r",
							"  s = String(s||\"\").toLowerCase();\r",
							"  const pairs = [\r",
							"    [/shch/g,\"щ\"], [/sch/g,\"щ\"], [/zh/g,\"ж\"], [/ch/g,\"ч\"], [/sh/g,\"ш\"],\r",
							"    [/yo/g,\"ё\"], [/yu/g,\"ю\"], [/ya/g,\"я\"], [/ye/g,\"е\"], [/kh/g,\"х\"], [/ts/g,\"ц\"]\r",
							"  ];\r",
							"  pairs.forEach(([re,rep]) => s = s.replace(re,rep));\r",
							"  const map = {a:\"а\",b:\"б\",c:\"к\",d:\"д\",e:\"е\",f:\"ф\",g:\"г\",h:\"х\",i:\"и\",j:\"й\",k:\"к\",l:\"л\",m:\"м\",n:\"н\",o:\"о\",p:\"п\",q:\"к\",r:\"р\",s:\"с\",t:\"т\",u:\"у\",v:\"в\",w:\"в\",x:\"кс\",y:\"ы\",z:\"з\",\"’\":\"\", \"'\":\"\"};\r",
							"  s = s.split(\"\").map(ch => map[ch] ?? ch).join(\"\");\r",
							"  // локальна правка під Tallin\r",
							"  s = s.replace(/таллинн/g,\"таллин\");\r",
							"  return s;\r",
							"}\r",
							"// простий ру->лат (достатньо для пошуку)\r",
							"function ruToLatin(s){\r",
							"  s = String(s||\"\").toLowerCase();\r",
							"  const map = {а:\"a\",б:\"b\",в:\"v\",г:\"g\",д:\"d\",е:\"e\",ё:\"yo\",ж:\"zh\",з:\"z\",и:\"i\",й:\"y\",\r",
							"               к:\"k\",л:\"l\",м:\"m\",н:\"n\",о:\"o\",п:\"p\",р:\"r\",с:\"s\",т:\"t\",у:\"u\",ф:\"f\",\r",
							"               х:\"kh\",ц:\"ts\",ч:\"ch\",ш:\"sh\",щ:\"shch\",ъ:\"\",ы:\"y\",ь:\"\",э:\"e\",ю:\"yu\",я:\"ya\"};\r",
							"  return s.split(\"\").map(ch => map[ch] ?? ch).join(\"\");\r",
							"}\r",
							"\r",
							"// 3) Парсимо URL\r",
							"const path = pm.request.url.path.slice();\r",
							"const buIdx = path.findIndex(p => /^bu-avto$/i.test(p) || /^auto$/i.test(p));\r",
							"const i = buIdx >= 0 ? buIdx + 1 : 0;\r",
							"const norm = s => decodeURIComponent(String(s||\"\"))\r",
							"  .replace(/\\.html$/i,\"\").replace(/-/g,\" \").replace(/\\s+/g,\" \").trim();\r",
							"\r",
							"const tokens = {\r",
							"  country: norm(path[i] || \"\"),      // estoniya\r",
							"  city:    norm(path[i+1] || \"\"),    // tallin\r",
							"  brand:   norm(path[i+2] || \"\"),    // lada\r",
							"  model:   norm(path[i+3] || \"\"),    // niva\r",
							"  year:    (path[i+4] || \"\").replace(/[^\\d]/g,\"\") // 2003\r",
							"};\r",
							"\r",
							"// 4) Допустимі варіанти написання для кожного токена\r",
							"function variants(s){\r",
							"  if (!s) return [];\r",
							"  const v = new Set();\r",
							"  v.add(canon(s));                   // як у URL\r",
							"  v.add(canon(latinToRu(s)));        // лат -> ру\r",
							"  v.add(canon(ruToLatin(s)));        // ру -> лат (на випадок кирилиці в URL)\r",
							"  return Array.from(v).filter(Boolean);\r",
							"}\r",
							"\r",
							"function expectToContain(label, list){\r",
							"  if (!list.length) return;\r",
							"  pm.test(`Title містить ${label}`, () => {\r",
							"    const ok = list.some(x => titleC.includes(x));\r",
							"    if (!ok) {\r",
							"      console.log(`MISS ${label}`, {title, candidates:list});\r",
							"    }\r",
							"    pm.expect(ok, `не знайдено жодного з: ${list.join(\" | \")}`).to.be.true;\r",
							"  });\r",
							"}\r",
							"\r",
							"// 5) Перевірки\r",
							"// country робимо м'яким (часто її немає у title) — лише лог\r",
							"const countryCands = variants(tokens.country);\r",
							"if (!countryCands.some(x => titleC.includes(x))) {\r",
							"  console.log(\"Country not found in title (це ок)\", {country: tokens.country, candidates: countryCands, title});\r",
							"}\r",
							"\r",
							"// обов'язкові: brand, model, city, year\r",
							"expectToContain(\"brand\", variants(tokens.brand));   // lada / лада\r",
							"expectToContain(\"model\", variants(tokens.model));   // niva / нива\r",
							"expectToContain(\"city\",  variants(tokens.city));    // tallin / таллин\r",
							"pm.test(\"Title має рік\", () => pm.expect(new RegExp(`\\\\b${tokens.year}\\\\b`).test(titleC)).to.be.true);\r",
							"\r",
							"// 6) Перевірка ціни\r",
							"const priceRegex = /по цене\\s*(\\d+)[€]/i;\r",
							"const priceMatch = html.match(priceRegex);\r",
							"const price = priceMatch ? parseInt(priceMatch[1], 10) : null;\r",
							"\r",
							"pm.test(\"Ціна існує і є числом\", () => {\r",
							"    pm.expect(price).to.not.be.null;\r",
							"    pm.expect(price).to.be.a('number');\r",
							"});\r",
							"\r",
							"// Додаткова перевірка на відомий діапазон цін (замініть нижчу і верхню межу на відповідні значення)\r",
							"const minPrice = 1000; //можна добавити змінну яка буде тягнути з фільтрів\r",
							"const maxPrice = 2000; //можна добавити змінну яка буде тягнути з фільтрів\r",
							"pm.test(\"Ціна в допустимому діапазоні\", () => {\r",
							"    pm.expect(price).to.be.within(minPrice, maxPrice);\r",
							"});\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://automoto.com.lv/ru/bu-avto/litva/ukmerge/toyota/avensis/2003/68589341.html",
					"protocol": "https",
					"host": [
						"automoto",
						"com",
						"lv"
					],
					"path": [
						"ru",
						"bu-avto",
						"litva",
						"ukmerge",
						"toyota",
						"avensis",
						"2003",
						"68589341.html"
					]
				}
			},
			"response": []
		},
		{
			"name": "SEO Listing Page",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const fromData = pm.iterationData.get('pageUrl');\r",
							"if (fromData) pm.variables.set('pageUrl', fromData);\r",
							"\r",
							"const url = pm.variables.get('pageUrl');\r",
							"if (!url) {\r",
							"  throw new Error('pageUrl is empty. Pass via --iteration-data or set env/collection variable.');\r",
							"}\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"/* ========== SEO Checks for Listing/Section Pages ========== */\r",
							"\r",
							"// 0) Підмінимо request URL з даних і виконаємо запит саме туди (Runner/Newman підставить pageUrl)\r",
							"if (pm.info.iteration === 0 && !pm.request.url.toString().includes(\"{{pageUrl}}\")) {\r",
							"  // Якщо ти вказав повний URL руками — усе ок; якщо стоїть {{pageUrl}}, просто ідемо далі\r",
							"}\r",
							"\r",
							"// 1) Базові перевірки\r",
							"pm.test(\"Status 200 OK\", () => pm.response.to.have.status(200));\r",
							"pm.test(\"Content-Type: text/html\", () => {\r",
							"  const ct = (pm.response.headers.get(\"content-type\") || \"\").toLowerCase();\r",
							"  pm.expect(ct).to.include(\"text/html\");\r",
							"});\r",
							"\r",
							"// 2) Витягуємо HTML\r",
							"const html = pm.response.text();\r",
							"const getOne = (re) => {\r",
							"  const m = html.match(re);\r",
							"  return m ? (m[1] || m[2] || \"\").toString().trim() : \"\";\r",
							"};\r",
							"const getAll = (re) => {\r",
							"  const arr = []; let m;\r",
							"  while ((m = re.exec(html)) !== null) arr.push((m[1] || m[2] || \"\").trim());\r",
							"  return arr;\r",
							"};\r",
							"const canon = s => String(s||\"\").toLowerCase().replace(/\\s+/g,\" \").trim();\r",
							"\r",
							"// 3) Основні мета-елементи\r",
							"const title      = getOne(/<title[^>]*>([\\s\\S]*?)<\\/title>/i);\r",
							"const metaDesc   = getOne(/<meta[^>]+name=[\"']description[\"'][^>]+content=[\"']([\\s\\S]*?)[\"'][^>]*>/i);\r",
							"const h1         = getOne(/<h1[^>]*>([\\s\\S]*?)<\\/h1>/i);\r",
							"const canonical  = getOne(/<link[^>]+rel=[\"']canonical[\"'][^>]+href=[\"']([^\"']+)[\"'][^>]*>/i);\r",
							"const robotsMeta = getOne(/<meta[^>]+name=[\"']robots[\"'][^>]+content=[\"']([^\"']+)[\"'][^>]*>/i);\r",
							"const ogTitle    = getOne(/<meta[^>]+property=[\"']og:title[\"'][^>]+content=[\"']([\\s\\S]*?)[\"'][^>]*>/i);\r",
							"const ogDesc     = getOne(/<meta[^>]+property=[\"']og:description[\"'][^>]+content=[\"']([\\s\\S]*?)[\"'][^>]*>/i);\r",
							"const hreflangs  = getAll(/<link[^>]+rel=[\"']alternate[\"'][^>]+hreflang=[\"']([^\"']+)[\"'][^>]+href=[\"']([^\"']+)[\"'][^>]*>/ig);\r",
							"\r",
							"// 4) Наявність/довжини\r",
							"pm.test(\"Title існує\", () => pm.expect(title).to.be.a(\"string\").and.not.empty);\r",
							"pm.test(\"Meta description існує\", () => pm.expect(metaDesc).to.be.a(\"string\").and.not.empty);\r",
							"pm.test(\"H1 існує\", () => pm.expect(h1).to.be.a(\"string\").and.not.empty);\r",
							"\r",
							"// дефолтні межі (можеш переозначити env-змінними)\r",
							"const minTitle = Number(pm.variables.get(\"seo_minTitle\") || 30);\r",
							"const maxTitle = Number(pm.variables.get(\"seo_maxTitle\") || 70);\r",
							"const minDesc  = Number(pm.variables.get(\"seo_minDesc\")  || 70);\r",
							"const maxDesc  = Number(pm.variables.get(\"seo_maxDesc\")  || 165);\r",
							"\r",
							"pm.test(`Title length ${minTitle}-${maxTitle}`, () => {\r",
							"  const len = title.trim().length;\r",
							"  pm.expect(len, `length=${len}`).to.be.within(minTitle, maxTitle);\r",
							"});\r",
							"pm.test(`Description length ${minDesc}-${maxDesc}`, () => {\r",
							"  const len = metaDesc.trim().length;\r",
							"  pm.expect(len, `length=${len}`).to.be.within(minDesc, maxDesc);\r",
							"});\r",
							"\r",
							"// 5) Canonical\r",
							"pm.test(\"Canonical існує\", () => pm.expect(canonical).to.be.a(\"string\").and.not.empty);\r",
							"pm.test(\"Canonical домен = домен запиту\", () => {\r",
							"  try {\r",
							"    const cHost = new URL(canonical).host;\r",
							"    const rHost = new URL(pm.request.url.toString()).host;\r",
							"    pm.expect(cHost).to.eql(rHost);\r",
							"  } catch(e) { /* пропускаємо якщо некоректний URL */ }\r",
							"});\r",
							"pm.test(\"Canonical без UTM/смiттєвих параметрів\", () => {\r",
							"  pm.expect(/[\\?&](utm_|fbclid|gclid)/i.test(canonical)).to.be.false;\r",
							"});\r",
							"\r",
							"// 6) Robots: за замовчанням очікуємо індексацію (noindex — false)\r",
							"const expectNoindex = String(pm.variables.get(\"seo_expectNoindex\") || \"false\").toLowerCase() === \"true\";\r",
							"pm.test(expectNoindex ? \"Robots містить noindex\" : \"Robots НЕ містить noindex\", () => {\r",
							"  const hasNoindex = /noindex/i.test(robotsMeta);\r",
							"  pm.expect(hasNoindex).to.eql(expectNoindex);\r",
							"});\r",
							"\r",
							"// 7) Узгодженість OG (не обов'язково суворо)\r",
							"pm.test(\"og:title узгоджений із <title> (м'яка перевірка)\", () => {\r",
							"  if (!ogTitle) return;\r",
							"  pm.expect(canon(ogTitle)).to.include(canon(title).split(\" \").slice(0,3).join(\" \"));\r",
							"});\r",
							"pm.test(\"og:description узгоджений із meta description (м'яка перевірка)\", () => {\r",
							"  if (!ogDesc) return;\r",
							"  pm.expect(canon(ogDesc)).to.include(canon(metaDesc).split(\" \").slice(0,5).join(\" \"));\r",
							"});\r",
							"\r",
							"// 8) Hreflang (якщо використовуються)\r",
							"pm.test(\"hreflang валідні (якщо присутні)\", () => {\r",
							"  pm.expect(Array.isArray(hreflangs)).to.be.true;\r",
							"  // Не фейлимо відсутність, але можна додати суворі правила під ваш сайт\r",
							"});\r",
							"\r",
							"// 9) (Опційно) Ключові слова — через змінні (налаштовуються у Variables)\r",
							"function tokensFromVar(name){\r",
							"  const raw = (pm.variables.get(name) || \"\").toString().trim();\r",
							"  return raw ? raw.split(\"|\").map(s => canon(s)).filter(Boolean) : [];\r",
							"}\r",
							"const titleTokens = tokensFromVar(\"seo_titleTokens\");\r",
							"const descTokens  = tokensFromVar(\"seo_descTokens\");\r",
							"\r",
							"if (titleTokens.length){\r",
							"  pm.test(`Title містить ключові слова: ${titleTokens.join(\" | \")}`, () => {\r",
							"    const t = canon(title);\r",
							"    titleTokens.forEach(tok => pm.expect(t).to.include(tok));\r",
							"  });\r",
							"}\r",
							"if (descTokens.length){\r",
							"  pm.test(`Description містить ключові слова: ${descTokens.join(\" | \")}`, () => {\r",
							"    const d = canon(metaDesc);\r",
							"    descTokens.forEach(tok => pm.expect(d).to.include(tok));\r",
							"  });\r",
							"}\r",
							"\r",
							"// 10) Збереження для дебагу\r",
							"pm.collectionVariables.set(\"seo_last_title\", title);\r",
							"pm.collectionVariables.set(\"seo_last_description\", metaDesc);\r",
							"pm.collectionVariables.set(\"seo_last_h1\", h1);\r",
							"pm.collectionVariables.set(\"seo_last_canonical\", canonical);\r",
							"\r",
							"const brandChunk = pm.variables.get(\"seo_brandSuffix\"); // напр. \"automoto\"\r",
							"if (brandChunk) {\r",
							"  pm.test(\"Title містить бренд-суксфікс\", () => {\r",
							"    pm.expect(canon(title)).to.include(canon(brandChunk));\r",
							"  });\r",
							"}\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "User-Agent",
						"value": "User-Agent: Mozilla/5.0",
						"type": "text"
					},
					{
						"key": "Accept",
						"value": " text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
						"type": "text"
					},
					{
						"key": "Accept-Language",
						"value": "ru,en;q=0.8",
						"type": "text"
					}
				],
				"url": {
					"raw": "{{pageUrl}}",
					"host": [
						"{{pageUrl}}"
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "city_ru",
			"value": ""
		},
		{
			"key": "city_en",
			"value": ""
		},
		{
			"key": "city_lv",
			"value": ""
		},
		{
			"key": "city_id",
			"value": "22",
			"type": "string",
			"description": {
				"content": "",
				"type": "text/plain"
			}
		},
		{
			"key": "cityExpected",
			"value": ""
		},
		{
			"key": "lastPageTitle",
			"value": ""
		}
	]
}